---
title: Campaign FFDA デプロイメントの概要
description: Campaign FFDA デプロイメントの概要
feature: Overview
role: Data Engineer
level: Beginner
source-git-commit: 6de5c93453ffa7761cf185dcbb9f1210abd26a0c
workflow-type: tm+mt
source-wordcount: '1019'
ht-degree: 67%

---

# [!DNL Campaign] FFDA デプロイメント{#gs-ac-ffda}

活用 [[!DNL Snowflake]](https://www.snowflake.com/)、Adobe Campaign Enterprise Full Federated Access(FFDA) の導入により、クラウドデータベーステクノロジーの規模と速度が大幅に向上し、より多くの顧客プロファイルを管理できるほか、1 時間あたりの配信率やトランザクション数も大幅に向上します。

## 利点 {#ffda-benefits}

Campaign v8 Enterprise(FFDA) は、ターゲティングから最終レポートまで、プロセスの任意の段階でエンドツーエンドの規模を実現します。

* 処理可能なデータ量を拡張（8 TB まで）
* セグメント化とターゲティングのためのクエリのパフォーマンスと、データの取り込みと取り出しのパフォーマンスを拡張
* 配信準備の拡大・縮小（数時間から数分まで）

これは、基本的なソフトウェアアーキテクチャの変更です。 データはリモートに格納され、Campaign によってプロファイルを含むデータ全体が統合されます。 [!DNL Campaign] プロセスは、ターゲティングからメッセージの実行に至るまで、エンドツーエンドで拡張できるようになりました。データの取り込み、セグメント化、ターゲティング、クエリ、配信などは通常、数分で実行されます。この新しいバージョンでは、柔軟性と拡張性のレベルを保ちながら、拡大および縮小の課題を解決します。 プロファイルの数にはほとんど制限がなく、データの保持期間も延長できます。

クラウドストレージは、**[!DNL Snowflake]** で実行されます。新しいビルトインの&#x200B;**外部アカウント**により、クラウドデータベースとの接続を確保します。
この設定はアドビがおこない、変更できません。 [詳細](../config/external-accounts.md)

クラウドデータベースで移動や複製が必要なビルトインのスキーマやテーブルには、**xxl** 名前空間にビルトインのスキーマ拡張機能が付属しています。この拡張機能には、ビルトインスキーマを [!DNL Campaign] ローカルデータベースから [!DNL Snowflake] クラウドデータベースに移動して、構成を適切に調整するために必要な変更（新しい UUID、リンクの更新など）が含まれます。


>[!CAUTION]
>
> 顧客データは、ローカルの [!DNL Campaign] データベースには格納されません。そのため、カスタムテーブルはクラウドデータベース内に作成する必要があります。

## Campaign Enterprise(FFDA) アーキテクチャ{#ffda-archi}

内 [エンタープライズ (FFDA) デプロイメント](../architecture/enterprise-deployment.md), [!DNL Adobe Campaign] v8 は、2 つのデータベースで動作します。地元の人 [!DNL Campaign] データベースを使用して、リアルタイムのメッセージングと単一のクエリを作成し、API を介して書き込み、およびクラウドを利用できます。 [!DNL Snowflake] キャンペーン実行、バッチクエリおよびワークフロー実行用のデータベース。

Campaign v8 Enterprise は、 **Federated Data Access** (FFDA):すべてのデータがクラウドデータベース上でリモートになりました。

ローカルデータベースとクラウドデータベースの間でデータを管理するには、特定の API を使用できます。 これらの新しい API の動作と使い方については、[このページ](new-apis.md)を参照してください。

サーバーとプロセス間の一般的な通信は、次のスキーマに従って実行されます。

![](assets/architecture.png)

* 実行とバウンスの管理モジュールがインスタンスで無効になっています。
* アプリケーションは、SOAP 呼び出し（HTTP または HTTPS 経由）を使用して駆動されるリモートの「ミッドソース」サーバーでメッセージを実行するように設定されています。

この [!DNL Snowflake] マーケティング側のデータベースは、次の目的で使用されます。

* すべての顧客データを保存：プロファイル、トランザクション、製品、場所などのカスタムデータ
* 配信ログ、トラッキングログ、プッシュ登録など、Campaign で生成または収集されたすべてのイベントと行動データを保存します。
* 上記のすべてのデータ集計を保存します。
* 参照テーブル（配信、列挙、国など）のコピー (h+1) を ワークフロー、キャンペーン、レポートで使用される
* すべてのバッチプロセスとワークロードを実行


マーケティングインスタンス上の PostgreSQL データベースは、次の目的で使用されます。

* ボリュームの少ない API など、特定のワークロードを実行します。
* 配信とキャンペーンの設定、ワークフロー、サービスの定義を含む、すべての Campaign データを保存します。
* すべての組み込み参照テーブル（列挙、国など）を （に複製） [!DNL Snowflake].

   ただし、次の操作はできません。
   * 顧客データのカスタマイズを作成します。例えば、PostgreSQL では世帯テーブルを作成せず、Snowflakeでのみ作成します。
   * 配信ログ、トラッキングログなどを保存します。 FFDA ターゲティングディメンションで使用できます。
   * 大量のデータを保存します。


ミッドソーシングインスタンス上の PostgreSQL データベースは、次の目的で使用されます。

* バッチ配信とリアルタイム (RT) 配信を実行します。
* 配信およびトラッキングログの送信 — 配信およびトラッキングログ ID は、32 ビット ID ではなく UUID です。
* トラッキングデータを収集し、保存します。


## 影響{#ffda-impacts}

### [!DNL Campaign] API のステージングメカニズム{#staging-api}

[!DNL Campaign] Cloud データベースでは、パフォーマンス（待ち時間と同時実行性）のため、単一呼び出しのブラストは推奨されません。 バッチ操作は常に推奨されます。 API の最適なパフォーマンスを保証するために、Campaign は API 呼び出しの処理をローカルデータベースレベルで継続します。

![](../assets/do-not-localize/glass.png) [API のステージングメカニズム について詳しくは、このページを参照してください。](staging.md)

### 新しい API{#new-apis}

[!DNL Campaign] ローカルデータベースと Cloud データベース間のデータ同期を管理する新しい API をご利用いただけます。また、遅延を回避し、全体的なパフォーマンスを向上させるために、ローカルデータベースレベルで API 呼び出しを処理する新しいメカニズムが導入されました。

![](../assets/do-not-localize/glass.png) [新しい API について詳しくは、このページを参照してください。](new-apis.md)


### データのレプリケーション{#data-replication}

Campaign のローカルデータベースとクラウドデータベースの両側に存在する必要があるテーブルは、特定のテクニカルワークフローでレプリケーションを処理します。 このワークフローは 1 時間ごとにトリガーされ、新規のビルトイン JavaScript ライブラリを活用します。

>[!NOTE]
>
> テーブルのサイズ（XS、XL など）に基づいて、複数のレプリケーションポリシーが作成されます。
> テーブルの中には、リアルタイムで複製されるものと、1 時間単位で複製されるものがあります。 テーブルには、増分更新をおこなうものと、完全に更新されるものがあります。

[データレプリケーションについて説明します](replication.md)

### ID 管理{#id-mgt-ffda}

Campaign v8 オブジェクトは、**UUID（ユニバーサルに一意の ID）**&#x200B;を使用するようになりました。これにより、一意の値（無制限）でデータを識別できます。

この ID は文字列で、連続していません。Campaign v8 ではプライマリキーは数値ではないため、スキーマで **autouuid** 属性と **autopk** 属性を使用する必要があります。

Campaign Classic v7 以前のバージョンでは、スキーマ（テーブルなど）のキーの単一性はデータベースエンジンのレベルで処理されます。 一般的に、従来のデータベースエンジン（PostgreSQL、Oracle、SQL Server など）では、プライマリキーや一意のインデックスの列を使用して、重複行を挿入しないようにするためのメカニズムをネイティブで備えています。 適切なインデックスとプライマリキーがデータベースレベルで設定されている限り、これらのバージョンでは ID の重複は発生しません。

Adobe Campaign v8 には、コアデータベースとして Snowflake が付属しています。クエリの規模が大幅に拡大するため、Snowflake データベースの分散アーキテクチャでは、テーブル内のキーの単一性を強制するそのようなメカニズムは提供されません。 そのため、Adobe Campaign v8 では、重複したキーがテーブルに取り込まれるのを防ぐことはできません。エンドユーザーは、Adobe Campaign データベース内のキーの一貫性を確保する責任を負うようになりました。 [詳細](keys.md)

**関連トピック**

* [データモデルのベストプラクティス](../dev/datamodel-best-practices.md)
